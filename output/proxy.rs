// Code generated by the multiversx-sc proxy generator. DO NOT EDIT.

////////////////////////////////////////////////////
////////////////// AUTO-GENERATED //////////////////
////////////////////////////////////////////////////

#![allow(dead_code)]
#![allow(clippy::all)]

use multiversx_sc::proxy_imports::*;

pub struct LunarPayProxy;

impl<Env, From, To, Gas> TxProxyTrait<Env, From, To, Gas> for LunarPayProxy
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    type TxProxyMethods = LunarPayProxyMethods<Env, From, To, Gas>;

    fn proxy_methods(self, tx: Tx<Env, From, To, (), Gas, (), ()>) -> Self::TxProxyMethods {
        LunarPayProxyMethods { wrapped_tx: tx }
    }
}

pub struct LunarPayProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    wrapped_tx: Tx<Env, From, To, (), Gas, (), ()>,
}

#[rustfmt::skip]
impl<Env, From, Gas> LunarPayProxyMethods<Env, From, (), Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    Gas: TxGas<Env>,
{
    pub fn init(
        self,
    ) -> TxTypedDeploy<Env, From, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_deploy()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LunarPayProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn upgrade(
        self,
    ) -> TxTypedUpgrade<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_upgrade()
            .original_result()
    }
}

#[rustfmt::skip]
impl<Env, From, To, Gas> LunarPayProxyMethods<Env, From, To, Gas>
where
    Env: TxEnv,
    Env::Api: VMApi,
    From: TxFrom<Env>,
    To: TxTo<Env>,
    Gas: TxGas<Env>,
{
    pub fn is_user_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, bool> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("isUserAdmin")
            .argument(&account)
            .original_result()
    }

    /// Stores the current whitelisted token identifiers 
    pub fn whitelisted_token_ids(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedTokenIds")
            .original_result()
    }

    /// Stores the used token identifiers 
    /// A token might get removed from the whitelist but the account might still have balance 
    pub fn used_token_ids(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, EgldOrEsdtTokenIdentifier<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUsedTokenIds")
            .original_result()
    }

    /// Stores the addresses that are allowed to create agreements 
    pub fn whitelisted_addresses(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, ManagedAddress<Env::Api>>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getWhitelistedAddresses")
            .original_result()
    }

    pub fn whitelist_token<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("whitelistToken")
            .argument(&token)
            .original_result()
    }

    pub fn remove_whitelisted_token<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
    >(
        self,
        token: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeWhitelistedToken")
            .argument(&token)
            .original_result()
    }

    pub fn whitelist_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("whitelistAddress")
            .argument(&address)
            .original_result()
    }

    pub fn remove_whitelisted_address<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeWhitelistedAddress")
            .argument(&address)
            .original_result()
    }

    pub fn set_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("setAdmin")
            .argument(&account)
            .original_result()
    }

    pub fn remove_admin<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        account: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("removeAdmin")
            .argument(&account)
            .original_result()
    }

    /// It returns the total account balances 
    pub fn get_account_balances<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, (EgldOrEsdtTokenIdentifier<Env::Api>, BigUint<Env::Api>)>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountBalances")
            .argument(&address)
            .original_result()
    }

    pub fn deposit_egld(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("depositEgld")
            .original_result()
    }

    pub fn withdraw_egld<
        Arg0: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        amount: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawEgld")
            .argument(&amount)
            .original_result()
    }

    pub fn deposit_esdt(
        self,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("depositEsdt")
            .original_result()
    }

    pub fn withdraw_esdt<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
    >(
        self,
        token: Arg0,
        amount: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("withdrawEsdt")
            .argument(&token)
            .argument(&amount)
            .original_result()
    }

    /// Stores the last ID assigned to an agreement 
    pub fn last_agreement_id(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getLastAgreementId")
            .original_result()
    }

    pub fn transfer_tokens<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        token: Arg0,
        amount: Arg1,
        receiver: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("transferTokens")
            .argument(&token)
            .argument(&amount)
            .argument(&receiver)
            .original_result()
    }

    pub fn pay<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<Option<ManagedBuffer<Env::Api>>>,
    >(
        self,
        token: Arg0,
        amount: Arg1,
        receiver: Arg2,
        metadata: Arg3,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("pay")
            .argument(&token)
            .argument(&amount)
            .argument(&receiver)
            .argument(&metadata)
            .original_result()
    }

    pub fn pay_with_egld_wallet_balance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<Option<ManagedBuffer<Env::Api>>>,
    >(
        self,
        receiver: Arg0,
        metadata: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("payWithEgldWalletBalance")
            .argument(&receiver)
            .argument(&metadata)
            .original_result()
    }

    pub fn pay_with_esdt_wallet_balance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<Option<ManagedBuffer<Env::Api>>>,
    >(
        self,
        receiver: Arg0,
        metadata: Arg1,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("payWithEsdtWalletBalance")
            .argument(&receiver)
            .argument(&metadata)
            .original_result()
    }

    pub fn donate<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<BigUint<Env::Api>>,
        Arg2: ProxyArg<ManagedAddress<Env::Api>>,
        Arg3: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg4: ProxyArg<Option<ManagedBuffer<Env::Api>>>,
    >(
        self,
        token: Arg0,
        amount: Arg1,
        receiver: Arg2,
        donation_link_id: Arg3,
        metadata: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("donate")
            .argument(&token)
            .argument(&amount)
            .argument(&receiver)
            .argument(&donation_link_id)
            .argument(&metadata)
            .original_result()
    }

    pub fn donate_with_egld_wallet_balance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<Option<ManagedBuffer<Env::Api>>>,
    >(
        self,
        receiver: Arg0,
        donation_link_id: Arg1,
        metadata: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("donateWithEgldWalletBalance")
            .argument(&receiver)
            .argument(&donation_link_id)
            .argument(&metadata)
            .original_result()
    }

    pub fn donate_with_esdt_wallet_balance<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
        Arg1: ProxyArg<ManagedBuffer<Env::Api>>,
        Arg2: ProxyArg<Option<ManagedBuffer<Env::Api>>>,
    >(
        self,
        receiver: Arg0,
        donation_link_id: Arg1,
        metadata: Arg2,
    ) -> TxTypedCall<Env, From, To, (), Gas, ()> {
        self.wrapped_tx
            .raw_call("donateWithEsdtWalletBalance")
            .argument(&receiver)
            .argument(&donation_link_id)
            .argument(&metadata)
            .original_result()
    }

    /// It returns the subscription charge amount information. 
    /// Returns: (pendingChargeAmount, affordableChargeAmount) 
    pub fn get_subscription_charge_amounts<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<OptionalValue<ManagedAddress<Env::Api>>>,
    >(
        self,
        id: Arg0,
        opt_address: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, (BigUint<Env::Api>, BigUint<Env::Api>)> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSubscriptionChargeAmounts")
            .argument(&id)
            .argument(&opt_address)
            .original_result()
    }

    /// It returns the subscription token outflow for a given account 
    pub fn get_user_subscriptions_outflow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, (EgldOrEsdtTokenIdentifier<Env::Api>, BigUint<Env::Api>)>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserSubscriptionsOutflow")
            .argument(&address)
            .original_result()
    }

    /// It returns the subscription token inflow for a given account 
    pub fn get_user_subscriptions_inflow<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, (EgldOrEsdtTokenIdentifier<Env::Api>, BigUint<Env::Api>)>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getUserSubscriptionsInflow")
            .argument(&address)
            .original_result()
    }

    pub fn subscription_ids(
        self,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getSubscriptionIds")
            .original_result()
    }

    /// Stores the IDs for all the subscriptions created by an account 
    pub fn account_subscriptions_created_list<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountSubscriptionsCreatedList")
            .argument(&address)
            .original_result()
    }

    /// Stores the IDs for all subscription signed by an account 
    pub fn account_subscriptions_membership_list<
        Arg0: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        address: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, MultiValueEncoded<Env::Api, u64>> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("getAccountSubscriptionsMembershipList")
            .argument(&address)
            .original_result()
    }

    pub fn create_subscription<
        Arg0: ProxyArg<EgldOrEsdtTokenIdentifier<Env::Api>>,
        Arg1: ProxyArg<u64>,
        Arg2: ProxyArg<SubscriptionType>,
        Arg3: ProxyArg<SubscriptionAmountType>,
        Arg4: ProxyArg<Option<BigUint<Env::Api>>>,
    >(
        self,
        token_identifier: Arg0,
        frequency: Arg1,
        subscription_type: Arg2,
        amount_type: Arg3,
        amount: Arg4,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, u64> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createSubscription")
            .argument(&token_identifier)
            .argument(&frequency)
            .argument(&subscription_type)
            .argument(&amount_type)
            .argument(&amount)
            .original_result()
    }

    pub fn add_subscription_member<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<ManagedAddress<Env::Api>>,
    >(
        self,
        id: Arg0,
        address: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("addSubscriptionMember")
            .argument(&id)
            .argument(&address)
            .original_result()
    }

    pub fn cancel_subscription_membership<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<Option<ManagedAddress<Env::Api>>>,
    >(
        self,
        id: Arg0,
        opt_address: Arg1,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("cancelSubscriptionMembership")
            .argument(&id)
            .argument(&opt_address)
            .original_result()
    }

    /// Subscribe to a subscription 
    pub fn create_subscription_membership<
        Arg0: ProxyArg<u64>,
        Arg1: ProxyArg<Option<BigUint<Env::Api>>>,
        Arg2: ProxyArg<Option<ManagedBuffer<Env::Api>>>,
    >(
        self,
        id: Arg0,
        amount: Arg1,
        metadata: Arg2,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("createSubscriptionMembership")
            .argument(&id)
            .argument(&amount)
            .argument(&metadata)
            .original_result()
    }

    pub fn trigger_subscription<
        Arg0: ProxyArg<u64>,
    >(
        self,
        id: Arg0,
    ) -> TxTypedCall<Env, From, To, NotPayable, Gas, ()> {
        self.wrapped_tx
            .payment(NotPayable)
            .raw_call("triggerSubscription")
            .argument(&id)
            .original_result()
    }
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum SubscriptionType {
    RecurringPayoutToSend,
    RecurringPayoutToReceive,
    TermRestrictedPayoutToSend,
    TermRestrictedPayoutToReceive,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub enum SubscriptionAmountType {
    FixedAmount,
    MemberDefinedAmount,
    OwnerDefinedAmountPerMember,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct SubscriptionChargeData<Api>
where
    Api: ManagedTypeApi,
{
    pub successful: Option<(BigUint<Api>, u64)>,
    pub failed: Option<(BigUint<Api>, u64)>,
}

#[type_abi]
#[derive(TopEncode, TopDecode)]
pub struct SubscriptionMultiChargeResult<Api>
where
    Api: ManagedTypeApi,
{
    pub account: ManagedAddress<Api>,
    pub data: (Option<(BigUint<Api>, u64)>, Option<(BigUint<Api>, u64)>),
}
